d3d11::cs-volume-renderer {
	string data_set = Assets/bonsai.dat
   string xfer_func = Assets/trrojan_zeiss1.brudervn
   uint32vec2 viewport = 1920 1080
	boolean debug_view = true

	float32 step_size = 0.25; 0.5; 1; 2

	string manoeuvre = path_z
	uint32 manoeuvre_steps = 100
	uint32 iterations = 2
	uint32 manoeuvre_step = 0; 24; 49; 74; 99

   uint32 min_wall_time = 200
}

d3d11::sphere-renderer {
	string data_set =  pos_rad_intensity : 2000000 : 0 : 10 10 10 : 0.01 0.1
   #string data_set =  pos_rad_intensity : 200 : 0 : 10 10 10 : 0.01 0.1
	uint32 frame = 0
   uint32vec2 viewport = 1920 1080
	boolean debug_view = true
	float32 global_radius = 0.07

	# Adaptation range for "adapt_poly_tess", "adapt_sphere_tess" and "adapt_hemisphere_tess"
	#uint32 adapt_tess_minimum = 4; 5
	#uint32 adapt_tess_maximum = 16; 25
	#float32 adapt_tess_scale = 3; 4

	# Fixed tessellation factors for "sphere_tess" and "hemisphere_tess".
	#float32vec4 edge_tess_factor = 4 4 4 4; 8 8 8 8
	#float32vec2 inside_tess_Factor = 4 4; 8 8

	# Fixed number of corners in polygon generated by "poly_tess".
	uint32 poly_corners = 5

	# Scaling of tessellation factor from "sphere" to "hemisphere" (and adaptive equivalents).
	float32 hemi_tess_scale = 0.5

	boolean conservative_depth = false
	boolean force_float_colour = false
	boolean vs_raygen = true;false
	boolean vs_xfer_function = true

	#string manoeuvre = orbit_x
	#string manoeuvre = orbit_y
	#string manoeuvre = orbit_z
	#string manoeuvre = orbit_-x
	#string manoeuvre = orbit_-y
	#string manoeuvre = orbit_-z
	#string manoeuvre = diagonal_x
	#string manoeuvre = diagonal_y
	#string manoeuvre = diagonal_z
	#string manoeuvre = path_x
	#string manoeuvre = path_y
	#string manoeuvre = path_z
	#string manoeuvre = path_sin_x
	#string manoeuvre = path_sin_y
	#string manoeuvre = path_sin_z
	#string manoeuvre = path_cos_x
	#string manoeuvre = path_cos_y
	#string manoeuvre = path_cos_z
	#string manoeuvre = random

	#string method = quad_inst; poly_tess; adapt_poly_tess; sphere_tess; adapt_sphere_tess; hemisphere_tess; adapt_hemisphere_tess; geo_quad; geo_poly; stpa
	#string method = quad_inst; poly_tess; adapt_poly_tess; geo_quad; stpa
   string method = quad_inst
	#string method = quad_tess
	#string method = quad_inst
	#string method = geo_quad
	#string method = hemisphere_tess; geo_quad; stpa

	string manoeuvre = path_z
	uint32 manoeuvre_steps = 100
	#uint32 manoeuvre_step = 0
	uint32 iterations = 10
	uint32 manoeuvre_step = 0; 9; 19; 29; 39; 49; 59; 69; 79; 89; 99
}

