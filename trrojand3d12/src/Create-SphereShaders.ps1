[CmdletBinding()]
param([Parameter(Mandatory = $true, ValueFromPipeline = $true)] [string] $OutPath,
    [string] $IncludeFile = "sphere_techniques.h",
    [string] $ResourceFile = "sphere_techniques.rc",
    [uint16] $ResourceStart = 256,
    [string] $ResourceType = "SHADER",
    [string] $RootSignatureDefine = "SHADER_ROOT_SIGNATURE")

begin {
    # Properties of the rendering techniques.
    $SPHERE_TECHNIQUE_USE_GEO = ([uint64] 1) -shl 31
    $SPHERE_TECHNIQUE_USE_TESS = ([uint64] 1) -shl 30
    $SPHERE_TECHNIQUE_USE_SRV =  ([uint64] 1) -shl 29
    $SPHERE_TECHNIQUE_USE_RAYCASTING = ([uint64] 1) -shl 28
    $SPHERE_TECHNIQUE_USE_INSTANCING = ([uint64] 1) -shl 27
    $SPHERE_TECHNIQUE_RESERVED_MMPLD = ([uint64] 1) -shl 26

    # Rendering techniques.
    $__SPHERE_TECH_BASE = ([uint64] 1) -shl 63
    $global:techniques = @{}
    $global:techniques[($__SPHERE_TECH_BASE -shr 0) -bor $SPHERE_TECHNIQUE_USE_SRV -bor $SPHERE_TECHNIQUE_USE_RAYCASTING -bor $SPHERE_TECHNIQUE_USE_INSTANCING] = "QUAD_INST"
    #$global:techniques[($__SPHERE_TECH_BASE -shr 1) -bor $SPHERE_TECHNIQUE_USE_SRV -bor $SPHERE_TECHNIQUE_USE_RAYCASTING -bor $SPHERE_TECHNIQUE_USE_INSTANCING] = "POLY_INST"
    $global:techniques[($__SPHERE_TECH_BASE -shr 2) -bor $SPHERE_TECHNIQUE_USE_TESS -bor $SPHERE_TECHNIQUE_USE_RAYCASTING] = "QUAD_TESS"
    $global:techniques[($__SPHERE_TECH_BASE -shr 3) -bor $SPHERE_TECHNIQUE_USE_TESS -bor $SPHERE_TECHNIQUE_USE_RAYCASTING] = "POLY_TESS"
    $global:techniques[($__SPHERE_TECH_BASE -shr 4) -bor $SPHERE_TECHNIQUE_USE_TESS -bor $SPHERE_TECHNIQUE_USE_RAYCASTING] = "ADAPT_POLY_TESS"
    $global:techniques[($__SPHERE_TECH_BASE -shr 5) -bor $SPHERE_TECHNIQUE_USE_GEO -bor $SPHERE_TECHNIQUE_USE_RAYCASTING] = "STPA"
    $global:techniques[($__SPHERE_TECH_BASE -shr 6) -bor $SPHERE_TECHNIQUE_USE_GEO -bor $SPHERE_TECHNIQUE_USE_RAYCASTING] = "GEO_QUAD"
    $global:techniques[($__SPHERE_TECH_BASE -shr 7) -bor $SPHERE_TECHNIQUE_USE_GEO -bor $SPHERE_TECHNIQUE_USE_RAYCASTING] = "GEO_POLY"
    $global:techniques[($__SPHERE_TECH_BASE -shr 8) -bor $SPHERE_TECHNIQUE_USE_TESS] = "SPHERE_TESS"
    $global:techniques[($__SPHERE_TECH_BASE -shr 9) -bor $SPHERE_TECHNIQUE_USE_TESS] = "ADAPT_SPHERE_TESS"
    $global:techniques[($__SPHERE_TECH_BASE -shr 10) -bor $SPHERE_TECHNIQUE_USE_TESS] = "HEMISPHERE_TESS"
    $global:techniques[($__SPHERE_TECH_BASE -shr 11) -bor $SPHERE_TECHNIQUE_USE_TESS] = "ADAPT_HEMISPHERE_TESS"
    # Note: Number of techniques must be below 32!

    # Properties of the input data.
    $SPHERE_INPUT_PV_COLOUR = ([uint64] 1) -shl 0       # mmpld::particle_properties::per_particle_colour
    $SPHERE_INPUT_PV_RADIUS = ([uint64] 1) -shl 1       # mmpld::particle_properties::per_particle_radius
    $SPHERE_INPUT_PV_INTENSITY = ([uint64] 1) -shl 2    # mmpld::particle_properties::per_particle_intensity
    $SPHERE_INPUT_FLT_COLOUR = ([uint64] 1) -shl 3      # mmpld::particle_properties::float_colour

    # Variants of the renderer.
    $SPHERE_INPUT_PP_INTENSITY = ([uint64] 1) -shl 8
    $SPHERE_VARIANT_PV_RAY = ([uint64] 1) -shl 9
    $SPHERE_VARIANT_CONSERVATIVE_DEPTH = ([uint64] 1) -shl 10

    # List of all techniques that have been created.
    $shaders = @{}

    # The header comment for all files.
    $global:header = "// This file was auto-generated by `"$($MyInvocation.Line)`" on $(Get-Date)"

    # Creates the wrapper of a single shader based on the given core
    # implementation.
    function New-Shader([string] $fileBase, [string] $core, [uint64] $technique, [uint64] $features) {
        $id = ($technique -bor $features)
        $retval = "$fileBase$("{0:X16}" -f $id)"
        $linearSampler = "addressU = TEXTURE_ADDRESS_CLAMP, addressV = TEXTURE_ADDRESS_CLAMP, addressW = TEXTURE_ADDRESS_CLAMP, filter = FILTER_MIN_MAG_MIP_LINEAR"
        $psDescriptorTable = @()
        $psSamplerTable = @()
        $vsDescriptorTable = @()
        $vsSamplerTable = @()
        $staticSamplers = @()

        $lines = @()
        $lines += $global:header

        # Select right technique and features.
        $lines += "#define $($global:techniques[$technique]) (1)"

        if ($features -band $SPHERE_INPUT_PV_COLOUR) {
            $lines += '#define PER_VERTEX_COLOUR (1)'
        }
        if ($features -band $SPHERE_INPUT_FLT_COLOUR) {
            $lines += '#define FLOAT_COLOUR (1)'
        }
        if ($features -band $SPHERE_INPUT_PV_RADIUS) {
            $lines += '#define PER_VERTEX_RADIUS (1)'
        }
        if ($features -band $SPHERE_INPUT_PV_INTENSITY) {
            $lines += '#define PER_VERTEX_INTENSITY (1)'
            $vsDescriptorTable += "SRV(t$($vsDescriptorTable.Length))"
            $staticSamplers += "StaticSampler(s0, $linearSampler, visibility = SHADER_VISIBILITY_VERTEX)"
        }
        if ($features -band $SPHERE_INPUT_PP_INTENSITY) {
            $lines += '#define PER_PIXEL_INTENSITY (1)'
            $psDescriptorTable += "SRV(t$($psDescriptorTable.Length))"
            $staticSamplers += "StaticSampler(s0, $linearSampler, visibility = SHADER_VISIBILITY_PIXEL)"
        }
        if ($features -band $SPHERE_VARIANT_PV_RAY) {
            $lines += '#define PER_VERTEX_RAY (1)'
        }
        if ($technique -band $SPHERE_TECHNIQUE_USE_RAYCASTING) {
            $lines += '#define RAYCASTING (1)'
        }
        if ($technique -band $SPHERE_TECHNIQUE_USE_INSTANCING) {
            $lines += '#define INSTANCING (1)'
            $vsDescriptorTable += "SRV(t$($vsDescriptorTable.Length))"
        }
        if ($technique -band $SPHERE_VARIANT_CONSERVATIVE_DEPTH) {
            $lines += '#define CONSERVATIVE_DEPTH (1)'
        }

        # Define a compatible root signature.
        $lines += "#define $RootSignatureDefine\";
        $lines += "    `"RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT),`"\"
        if ($vsDescriptorTable.Length -gt 0) {
            $lines += "    `"DescriptorTable($($vsDescriptorTable -join ', '), visibility = SHADER_VISIBILITY_VERTEX),`"\"
        }
        if ($vsSamplerTable.Length -gt 0) {
            $lines += "    `"DescriptorTable($($vsSamplerTable -join ', '), visibility = SHADER_VISIBILITY_VERTEX),`"\"
        }
        if ($psDescriptorTable.Length -gt 0) {
            $lines += "    `"DescriptorTable($($psDescriptorTable -join ', '), visibility = SHADER_VISIBILITY_PIXEL),`"\"
        }
        if ($psSamplerTable.Length -gt 0) {
            $lines += "    `"DescriptorTable($($psSamplerTable -join ', '), visibility = SHADER_VISIBILITY_PIXEL),`"\"
        }
        $staticSamplers | Foreach-Object {
            $lines += "    `"$_,`"\"
        }
        $lines += "    `"DescriptorTable(CBV(b0), CBV(b1), CBV(b2), visibility=SHADER_VISIBILITY_ALL)`""

        # Include the actual implementation.
        $lines += "#include `"$core`""

        $file = "$retval.hlsl"
        $file = Join-Path $OutPath $file
        $lines | Out-File -FilePath $file -Encoding ascii

        return $retval
    }
}

process {
    0..1 | %{
        $pvRadius = $_ * $SPHERE_INPUT_PV_RADIUS
        
        0..2 | %{
            $pvColour = ([int] ($_ / 2)) * $SPHERE_INPUT_PV_COLOUR
            $pvIntensity = ($_ % 2) * $SPHERE_INPUT_PV_INTENSITY
            #echo "RAD $pvRadius"
            #echo "COL $pvColour"
            #echo "INT $pvIntensity"

            $cntXfer = 0
            if ($pvIntensity -ne 0) {
                # Technique has per-vertex intensity, so we need to test VS
                # texture lookup and PS texture lookup.
                $cntXfer = 1
            }

            0..$cntXfer | %{
                $xfer = ($_ * $SPHERE_INPUT_PP_INTENSITY) -bor ((1 - $_) * $pvIntensity)
                                
                $global:techniques.Keys | %{
                    $technique = $_
                
                    $cntFlt = 0
                    if (($technique -band $SPHERE_TECHNIQUE_USE_SRV) -and ($pvColour -ne 0)) {
                        # Technique uses structured resource view and format
                        # includes colour, so we need to include in-shader RGB8 to
                        # float conversion and host code conversion.
                        $cntFlt = 1
                    }

                    $cntRay = 0
                    $cntConvDepth = 0
                    if ($technique -band $SPHERE_TECHNIQUE_USE_RAYCASTING) {
                        # If the technique uses raycasting, test per-vertex and
                        # per-pixel generation of rays. Also, raycasting supports
                        # optional conservative depth.
                        $cntRay = 1
                        $cntConvDepth = 1
                    }

                    0..$cntFlt | %{
                        $flt = $_ * $SPHERE_INPUT_FLT_COLOUR


                        0..$cntRay | %{
                            $pvRay = $_ * $SPHERE_VARIANT_PV_RAY

                            0..$cntConvDepth | %{
                                $convDepth = $_ * $SPHERE_VARIANT_CONSERVATIVE_DEPTH

                                $features = ($pvRadius -bor $pvColour -bor $flt -bor $xfer -bor $pvRay -bor $convDepth)
                                $id = ($technique -bor $features)
                                $shader = New-Object PSObject
                        
                                $vs = New-Shader "SphereVertexShader" "SphereVertexShaderCore.hlsli" $technique $features
                                $shader | Add-Member NoteProperty VertexShader $vs

                                if ($technique -band $SPHERE_TECHNIQUE_USE_TESS) {
                                    $hs = New-Shader "SphereHullShader" "SphereHullShaderCore.hlsli" $technique $features
                                    $shader | Add-Member NoteProperty HullShader $hs
                                    $ds = New-Shader "SphereDomainShader" "SphereDomainShaderCore.hlsli" $technique $features
                                    $shader | Add-Member NoteProperty DomainShader $ds
                                }

                                if ($technique -band $SPHERE_TECHNIQUE_USE_GEO) {
                                    $gs = New-Shader "SphereGeometryShader" "SphereGeometryShaderCore.hlsli" $technique $features
                                    $shader | Add-Member NoteProperty GeometryShader $gs
                                }

                                $ps = New-Shader "SpherePixelShader" "SpherePixelShaderCore.hlsli" $technique $features
                                $shader | Add-Member NoteProperty PixelShader $ps

                                $shaders[$id] = $shader
                            }
                        }
                    }
                }
            }
        }
    }


    # The lines of the include file to be generated.
    $includes = @()
    $includes += $global:header

    $includes += "#define SPHERE_TECHNIQUE_USE_GEO ($("0x{0:X}" -f $SPHERE_TECHNIQUE_USE_GEO))"
    $includes += "#define SPHERE_TECHNIQUE_USE_TESS ($("0x{0:X}" -f $SPHERE_TECHNIQUE_USE_TESS))"
    $includes += "#define SPHERE_TECHNIQUE_USE_SRV ($("0x{0:X}" -f $SPHERE_TECHNIQUE_USE_SRV))"
    $includes += "#define SPHERE_TECHNIQUE_USE_RAYCASTING ($("0x{0:X}" -f $SPHERE_TECHNIQUE_USE_RAYCASTING))"
    $includes += "#define SPHERE_TECHNIQUE_USE_INSTANCING ($("0x{0:X}" -f $SPHERE_TECHNIQUE_USE_INSTANCING))"
    $includes += "#define SPHERE_INPUT_PV_COLOUR ($("0x{0:X}" -f $SPHERE_INPUT_PV_COLOUR))"
    $includes += "#define SPHERE_INPUT_PV_RADIUS ($("0x{0:X}" -f $SPHERE_INPUT_PV_RADIUS))"
    $includes += "#define SPHERE_INPUT_PV_INTENSITY ($("0x{0:X}" -f $SPHERE_INPUT_PV_INTENSITY))"
    $includes += "#define SPHERE_INPUT_PP_INTENSITY ($("0x{0:X}" -f $SPHERE_INPUT_PP_INTENSITY))"
    $includes += "#define SPHERE_INPUT_FLT_COLOUR ($("0x{0:X}" -f $SPHERE_INPUT_FLT_COLOUR))"
    $includes += "#define SPHERE_VARIANT_PV_RAY ($("0x{0:X}" -f $SPHERE_VARIANT_PV_RAY))"
    $includes += "#define SPHERE_VARIANT_CONSERVATIVE_DEPTH ($("0x{0:X}" -f $SPHERE_VARIANT_CONSERVATIVE_DEPTH))"
    $includes += "#define SPHERE_TECHNIQUE_RESERVED_MMPLD ($("0x{0:X}" -f $SPHERE_TECHNIQUE_RESERVED_MMPLD))"

    $global:techniques.Keys | %{
        $includes +="#define SPHERE_TECHNIQUE_$($global:techniques[$_]) ($("0x{0:X}" -f $_)ull)"
    }

    $includes += "#define _DEFINE_SPHERE_TECHNIQUE_LUT(n) static const struct { const char *name; std::uint64_t id; } n[] = {\"
    $global:techniques.Keys | %{
        $includes +="{ `"$($global:techniques[$_].ToLower())`", $("0x{0:X}" -f $_)ull },\"
    }
    $includes += "{ nullptr, 0 } }"

    # The lines of the resource script to be generated.
    $resources = @()
    $resources += $global:header
    #$resources += "#include `"$IncludeFile`""

    # The current resource ID.
    $resID = $ResourceStart


    $resLookup = @("#define _LOOKUP_SPHERE_SHADER_RESOURCES(builder, id)\")
    $fileLookup = @("#define _LOOKUP_SPHERE_SHADER_FILES(builder, id, resolve_path)\")
    $resLookup += "switch (id) {\"
    $fileLookup += "switch (id) {\"

    $shaders.Keys | Foreach-Object {
        $id = $_
        $shader = $shaders[$id]
        $vs = $shader.VertexShader
        $hs = $shader.HullShader
        $ds = $shader.DomainShader
        $gs = $shader.GeometryShader
        $ps = $shader.PixelShader

        $resLookup += "    case ($($id)):\"
        $fileLookup += "   case ($($id)):\"
        if ($vs) {
            $resources += "$resID $ResourceType $vs.cso"
            $resLookup += "        builder.set_vertex_shader_from_resource(MAKEINTRESOURCE($resID), _T(`"$ResourceType`"));\"
            $fileLookup += "        builder.set_vertex_shader_from_file(resolve_path(`"$vs.cso`"));\"
            ++$resID
        }

        if ($hs) {
            $resources += "$resID $ResourceType $hs.cso"
            $resLookup += "        builder.set_hull_shader_from_resource(MAKEINTRESOURCE($resID), _T(`"$ResourceType`"));\"
            $fileLookup += "        builder.set_vertex_shader_from_file(resolve_path(`"$hs.cso`"));\"
            ++$resID
        }

        if ($ds) {
            $resources += "$resID $ResourceType $ds.cso"
            $resLookup += "        builder.set_domain_shader_from_resource(MAKEINTRESOURCE($resID), _T(`"$ResourceType`"));\"
            $fileLookup += "        builder.set_vertex_shader_from_file(resolve_path(`"$ds.cso`"));\"
            ++$resID
        }

        if ($gs) {
            $resources += "$resID $ResourceType $gs.cso"
            $resLookup += "        builder.set_geometry_shader_from_resource(MAKEINTRESOURCE($resID), _T(`"$ResourceType`"));\"
            $fileLookup += "        builder.set_vertex_shader_from_file(resolve_path(`"$gs.cso`"));\"
            ++$resID
        }

        if ($ps) {
            $resources += "$resID $ResourceType $ps.cso"
            $resLookup += "        builder.set_pixel_shader_from_resource(MAKEINTRESOURCE($resID), _T(`"$ResourceType`"));\"
            $fileLookup += "        builder.set_vertex_shader_from_file(resolve_path(`"$ps.cso`"));\"
            ++$resID
        }

        $resLookup += "        break;\"
        $fileLookup += "        break;\"
    }

    $resLookup += "    }"
    $fileLookup += "    }"

    $includes += $resLookup
    $includes += $fileLookup

    $includes | Out-File -FilePath (Join-Path $OutPath $IncludeFile) -Encoding ascii 
    $resources | Out-File -FilePath (Join-Path $OutPath $ResourceFile) -Encoding ascii

    Write-Verbose "$($shaders.Count) have been generated."
}

end { }

